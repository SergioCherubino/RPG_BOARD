<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>RPG Board</title>

<style>
  body {
    background-color: #222;
    color: #eee;
    font-family: Arial;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(10, 40px);
    grid-template-rows: repeat(10, 40px);
    gap: 2px;
    margin-top: 20px;
  }

  .cell {
    width: 40px;
    height: 40px;
    background: #444;
    border: 1px solid #555;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
  }

  .player {
    color: #4af;
    font-weight: bold;
  }

  .monster {
    color: #f44;
    font-weight: bold;
  }

  /* Console abaixo do tabuleiro */
  #consoleBox {
    width: 420px;
    height: 150px;
    background: #111;
    color: #0f0;
    border: 2px solid #0f0;
    margin-top: 15px;
    overflow-y: auto;
    padding: 8px;
    font-family: "Courier New", monospace;
    font-size: 14px;
    white-space: pre-line;
  }
</style>
</head>

<body>

<h2>RPG Board Game</h2>

<div id="board"></div>

<!-- Console onde logs aparecer√£o -->
<div id="consoleBox"></div>

<script>

// =========================================================
// ===================== SISTEMA DO BOARD ==================
// =========================================================

const boardSize = 10;

const board = []; // matriz 10x10
let boardDiv = document.getElementById("board");
let consoleBox = document.getElementById("consoleBox");

// Cria matriz vazia
for (let y = 0; y < boardSize; y++) {
  board[y] = [];
  for (let x = 0; x < boardSize; x++) {
    board[y][x] = null;
  }
}

// Redesenha tudo no HTML
function renderBoard() {
  boardDiv.innerHTML = "";

  for (let y = 0; y < boardSize; y++) {
    for (let x = 0; x < boardSize; x++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");

      if (board[y][x]) {
        const ent = board[y][x];

        if (ent.type === "player") {
          cell.innerHTML = "üßç";
          cell.classList.add("player");
        } else if (ent.type === "monster") {
          cell.innerHTML = "üëπ";
          cell.classList.add("monster");
        }
      }

      boardDiv.appendChild(cell);
    }
  }
}

// =========================================================
// ======================= ENTIDADES ========================
// =========================================================

const player = {
  type: "player",
  x: 0,
  y: 0,
  AC: 12,
  hp: 20
};

const monsters = [
  { id:1, type:"monster", x:7, y:2, AC:10, hp:10 },
  { id:2, type:"monster", x:5, y:8, AC:11, hp:12 }
];

// Coloca entidades no board
function placeEntity(ent, x, y) {
  board[y][x] = ent;
  ent.x = x;
  ent.y = y;
}

// Limpa c√©lula
function clearCell(x, y) {
  board[y][x] = null;
}

// Inicia posi√ß√µes
placeEntity(player, 0, 0);
for (let m of monsters) placeEntity(m, m.x, m.y);

renderBoard();


// =========================================================
// ======================== CONSOLE =========================
// =========================================================

function log(msg) {
  consoleBox.innerHTML += msg + "\n";
  consoleBox.scrollTop = consoleBox.scrollHeight;
}


// =========================================================
// ======================= ATAQUE ===========================
// =========================================================

// Somente ortogonal
function isAdjacent(x1, y1, x2, y2) {
  return (
    (x1 + 1 === x2 && y1 === y2) ||
    (x1 - 1 === x2 && y1 === y2) ||
    (y1 + 1 === y2 && x1 === x2) ||
    (y1 - 1 === y2 && x1 === x2)
  );
}

function rollD20() {
  return Math.floor(Math.random() * 20) + 1;
}

function playerAttack(monster) {
  const d20 = rollD20();

  if (d20 < monster.AC) {
    log(`Player attacks Monster ${monster.id}: HIT (d20=${d20} < AC ${monster.AC})`);
    const dmg = Math.floor(Math.random()*6)+1;
    monster.hp -= dmg;
    log(`Player damages Monster ${monster.id}: ${dmg}`);

    if (monster.hp <= 0) {
      clearCell(monster.x, monster.y);
      log(`Monster ${monster.id} died!`);
    }
  } else {
    log(`Player attacks Monster ${monster.id}: MISS (d20=${d20} >= AC ${monster.AC})`);
  }

  renderBoard();
}

function monsterAttack(monster) {
  const d20 = rollD20();

  if (d20 < player.AC) {
    log(`Monster ${monster.id} attacks Player: HIT (d20=${d20} < AC ${player.AC})`);
    const dmg = Math.floor(Math.random()*4)+1;
    player.hp -= dmg;
    log(`Player takes ${dmg} damage! (HP=${player.hp})`);
  } else {
    log(`Monster ${monster.id} attacks Player: MISS (d20=${d20} >= AC ${player.AC})`);
  }

  renderBoard();
}

// ======================================================================
// ======== FIM DA PARTE 1/2 ‚Äî A PARTE 2 TEM A IA COMPLETA BFS ==========
// ======================================================================
// ---------------------- PARTE 2/2 (CONTINUA√á√ÉO DO <script>) ----------------------

// ======== Ajustes iniciais (movementRange padr√£o para monstros) ========
for (let m of monsters) {
  if (m.movementRange === undefined) m.movementRange = 2; // padr√£o
}

// ------ sobrescreve renderBoard para adicionar handlers de clique e mostrar HP ------
function renderBoard() {
  boardDiv.innerHTML = "";

  for (let y = 0; y < boardSize; y++) {
    for (let x = 0; x < boardSize; x++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");

      // registro de coordenadas no DOM
      cell.dataset.x = x;
      cell.dataset.y = y;

      if (board[y][x]) {
        const ent = board[y][x];

        if (ent.type === "player") {
          cell.innerHTML = "üßç";
          cell.classList.add("player");
          // mostra HP pequeno
          const hp = document.createElement("div");
          hp.style.position = "absolute";
          hp.style.fontSize = "10px";
          hp.style.bottom = "2px";
          hp.style.right = "4px";
          hp.style.color = "#8ff";
          hp.textContent = `HP:${ent.hp}`;
          cell.appendChild(hp);
        } else if (ent.type === "monster") {
          cell.innerHTML = "üëπ";
          cell.classList.add("monster");
          const hp = document.createElement("div");
          hp.style.position = "absolute";
          hp.style.fontSize = "10px";
          hp.style.bottom = "2px";
          hp.style.right = "4px";
          hp.style.color = "#f88";
          hp.textContent = `HP:${ent.hp}`;
          cell.appendChild(hp);
        }
      }

      // clique na c√©lula
      cell.addEventListener("click", () => {
        onCellClicked(x, y);
      });

      boardDiv.appendChild(cell);
    }
  }
}

// chama uma vez pra garantir handlers atualizados
renderBoard();

// ---------------------- utilidades ----------------------
function inBounds(x, y) {
  return x >= 0 && x < boardSize && y >= 0 && y < boardSize;
}

function findMonsterAt(x, y) {
  for (let m of monsters) {
    if (m.x === x && m.y === y) return m;
  }
  return null;
}

// ---------------------- A√á√ÉO DO JOGADOR (click) ----------------------
let playerHasActed = false; // impede m√∫ltiplas a√ß√µes antes de passar o turno (simples)

function onCellClicked(x, y) {
  if (player.hp <= 0) { log("Voc√™ est√° morto. Reinicie o jogo."); return; }

  // se clicou em monstro adjacente: atacar
  const mon = findMonsterAt(x, y);
  if (mon && isAdjacent(player.x, player.y, x, y)) {
    if (playerHasActed) { log("Voc√™ j√° agiu. Clique 'End Turn' para os monstros."); return; }
    playerAttack(mon);
    playerHasActed = true;
    log("(Player a√ß√£o conclu√≠da ‚Äî clique End Turn para o turno dos monstros)");
    return;
  }

  // se c√©lula vazia e ortogonal adjacente -> mover 1 tile
  if (!board[y][x] && isAdjacent(player.x, player.y, x, y)) {
    if (playerHasActed) { log("Voc√™ j√° agiu. Clique 'End Turn' para os monstros."); return; }
    clearCell(player.x, player.y);
    placeEntity(player, x, y);
    renderBoard();
    playerHasActed = true;
    log(`Player moves to (${x},${y})`);
    return;
  }

  // clique inv√°lido
  log("Clique inv√°lido ‚Äî mova/atque apenas em tiles ortogonais adjacentes.");
}

// ---------------------- BFS (somente ortogonal) ----------------------
function findPathBFS(startX, startY, goalsSet, monster) {
  // goalsSet = array de posi√ß√µes {x,y} que s√£o destinos v√°lidos
  // monster: entidade que est√° buscando o caminho (usado para permitir sua pr√≥pria posi√ß√£o como livre)
  const key = (p) => `${p.x},${p.y}`;
  const queue = [];
  const visited = new Set();

  queue.push({ x: startX, y: startY, path: [] });
  visited.add(`${startX},${startY}`);

  const dirs = [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 }
  ];

  // normalize goals into a set for quick check
  const goalsMap = new Set(goalsSet.map(g => key(g)));

  while (queue.length > 0) {
    const cur = queue.shift();

    // se cur estiver em goalsMap -> retorna caminho
    if (goalsMap.has(key(cur))) {
      return cur.path; // array de passos (cada passo √© {x,y})
    }

    for (const d of dirs) {
      const nx = cur.x + d.x;
      const ny = cur.y + d.y;
      const nkey = `${nx},${ny}`;

      if (!inBounds(nx, ny)) continue;
      if (visited.has(nkey)) continue;

      // n√£o pode atravessar o jogador
      if (nx === player.x && ny === player.y) continue;

      // pode atravessar somente tiles vazios ou o pr√≥prio monstro (no in√≠cio)
      const occ = board[ny][nx];
      if (occ && occ !== monster) continue;

      visited.add(nkey);
      const newPath = cur.path.concat([{ x: nx, y: ny }]);
      queue.push({ x: nx, y: ny, path: newPath });
    }
  }

  // sem caminho
  return null;
}

// ---------------------- Movimento do monstro seguindo o caminho (async) ----------------------
function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

async function moveMonsterAlong(monster, path, maxSteps) {
  // path √© array de posi√ß√µes a partir do passo 1 (n√£o inclui posi√ß√£o inicial)
  const steps = Math.min(maxSteps, path.length);
  for (let i = 0; i < steps; i++) {
    const p = path[i];
    // mover
    clearCell(monster.x, monster.y);
    placeEntity(monster, p.x, p.y);
    log(`Monster ${monster.id} moves to (${p.x},${p.y})`);
    renderBoard();
    await sleep(220);
  }
}

// ---------------------- Turno dos monstros (async) ----------------------
async function monsterTurn() {
  log("=== Turno dos monstros iniciado ===");
  for (let monster of monsters.slice()) {
    // se o monstro morreu durante o turno (pode ocorrer), pule
    if (monster.hp <= 0) continue;
    // confirmar que o monstro ainda est√° no mapa (posi√ß√£o consistente)
    if (!inBounds(monster.x, monster.y)) continue;
    if (board[monster.y][monster.x] !== monster) {
      // tentar localizar pelo id (caso tenha sido movido)
      const found = findMonsterAt(monster.x, monster.y);
      if (!found) {
        // procurar por matching id
        let located = null;
        for (let y = 0; y < boardSize; y++) {
          for (let x = 0; x < boardSize; x++) {
            const occ = board[y][x];
            if (occ && occ.id === monster.id) located = occ;
          }
        }
        if (located) monster = located;
        else continue;
      }
    }

    // 1) se j√° adjacente ortogonal -> atacar
    if (isAdjacent(monster.x, monster.y, player.x, player.y)) {
      log(`Monster ${monster.id} is adjacent and attacks!`);
      monsterAttack(monster);
      if (player.hp <= 0) {
        log("Player morreu. Game Over.");
        renderBoard();
        return;
      }
      await sleep(180);
      continue;
    }

    // 2) determinar posi√ß√µes alvo: as 4 c√©lulas ortogonais ao redor do jogador que sejam inBounds
    const goalPositions = [
      { x: player.x + 1, y: player.y },
      { x: player.x - 1, y: player.y },
      { x: player.x, y: player.y + 1 },
      { x: player.x, y: player.y - 1 }
    ].filter(p => inBounds(p.x, p.y));

    // preferir objetivos vazios (n√£o ocupados por outro monstro)
    const emptyGoals = goalPositions.filter(p => !board[p.y][p.x] || board[p.y][p.x] === monster);

    // se nenhum goal vazio, ainda tentamos pathfinder para qualquer goal (mas BFS bloqueado pelos ocupantes)
    const goalsToTry = emptyGoals.length > 0 ? emptyGoals : goalPositions;

    const path = findPathBFS(monster.x, monster.y, goalsToTry, monster);

    if (path && path.length > 0) {
      // mover at√© movementRange passos seguindo path
      const steps = monster.movementRange || 1;
      await moveMonsterAlong(monster, path, steps);

      // ap√≥s mover, checar se agora adjacente -> atacar
      if (isAdjacent(monster.x, monster.y, player.x, player.y)) {
        log(`Monster ${monster.id} reached adjacency and attacks!`);
        monsterAttack(monster);
        if (player.hp <= 0) {
          log("Player morreu. Game Over.");
          renderBoard();
          return;
        }
      }
    } else {
      log(`Monster ${monster.id} cannot find path to player (blocked).`);
      // tentar mover para alguma c√©lula ortogonal livre que aproxime (heur√≠stica simples)
      const candidates = [
        { x: monster.x + 1, y: monster.y },
        { x: monster.x - 1, y: monster.y },
        { x: monster.x, y: monster.y + 1 },
        { x: monster.x, y: monster.y - 1 }
      ].filter(p => inBounds(p.x,p.y) && canMonsterStepTo(p.x,p.y));
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        clearCell(monster.x, monster.y);
        placeEntity(monster, pick.x, pick.y);
        log(`Monster ${monster.id} shuffles to (${pick.x},${pick.y})`);
        renderBoard();
        await sleep(180);
      } else {
        log(`Monster ${monster.id} stays in place (fully blocked).`);
        await sleep(120);
      }
    }
  }

  log("=== Turno dos monstros finalizado ===");
  // back to player
  playerHasActed = false;
  renderBoard();
}

// ---------------------- End Turn button ----------------------
const endBtn = document.createElement("button");
endBtn.textContent = "End Turn";
endBtn.style.marginTop = "10px";
endBtn.onclick = () => {
  if (playerHasActed === false) {
    log("Voc√™ n√£o agiu ‚Äî ainda assim passar o turno √© permitido.");
  }
  monsterTurn();
};
document.body.appendChild(endBtn);

// ---------------------- FIM DA PARTE 2/2 ----------------------
  </script>
</body>
</html>